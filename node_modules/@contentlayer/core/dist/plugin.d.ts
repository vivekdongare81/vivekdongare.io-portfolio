import type { Thunk } from '@contentlayer/utils';
import type { E, HasClock, HasConsole, OT, S, T } from '@contentlayer/utils/effect';
import type { BundleMDXOptions } from 'mdx-bundler/dist/types';
import type { LiteralUnion } from 'type-fest';
import type * as unified from 'unified';
import type { HasCwd } from './cwd.js';
import type { DataCache } from './DataCache.js';
import type { SourceFetchDataError, SourceProvideSchemaError } from './errors.js';
import type { SchemaDef, StackbitExtension } from './schema/index.js';
export declare type SourcePluginType = LiteralUnion<'local' | 'contentful' | 'sanity', string>;
export declare type PluginExtensions = {
    stackbit?: StackbitExtension.Config;
};
export declare type PluginOptions = {
    markdown: MarkdownOptions | undefined;
    mdx: MDXOptions | undefined;
    date: DateOptions | undefined;
    fieldOptions: FieldOptions;
};
export declare type MarkdownOptions = {
    remarkPlugins?: unified.Pluggable[];
    rehypePlugins?: unified.Pluggable[];
};
export declare type MDXOptions = {
    remarkPlugins?: unified.Pluggable[];
    rehypePlugins?: unified.Pluggable[];
} & Omit<BundleMDXOptions<any>, 'xdmOptions'>;
export declare type DateOptions = {
    /**
     * Use provided timezone (e.g. `America/New_York`)
     *
     * Based on: https://github.com/marnusw/date-fns-tz#zonedtimetoutc
     */
    timezone?: string;
};
export declare type FieldOptions = {
    /**
     * Name of the field containing the body/content extracted when `contentType` is `markdown` or `mdx`.
     * @default "body"
     */
    bodyFieldName: string;
    /**
     * Name of the field containing the name of the document type (or nested document type).
     * @default "type"
     */
    typeFieldName: string;
};
export declare type SourcePlugin = {
    type: SourcePluginType;
    provideSchema: ProvideSchema;
    fetchData: FetchData;
} & {
    options: PluginOptions;
    extensions: PluginExtensions;
};
export declare type ProvideSchema = T.Effect<OT.HasTracer & HasConsole, SourceProvideSchemaError, SchemaDef>;
export declare type FetchData = (_: {
    schemaDef: SchemaDef;
    verbose: boolean;
}) => S.Stream<OT.HasTracer & HasClock & HasCwd & HasConsole, never, E.Either<SourceFetchDataError | SourceProvideSchemaError, DataCache.Cache>>;
export declare type MakeSourcePlugin<TArgs extends PartialArgs> = (_: TArgs | Thunk<TArgs> | Thunk<Promise<TArgs>>) => Promise<SourcePlugin>;
export declare type PartialArgs = {
    markdown?: MarkdownOptions | undefined;
    mdx?: MarkdownOptions | undefined;
    date?: DateOptions | undefined;
    fieldOptions?: Partial<FieldOptions>;
    extensions?: PluginExtensions;
};
export declare const defaultFieldOptions: FieldOptions;
export declare const processArgs: <TArgs extends PartialArgs>(argsOrArgsThunk: TArgs | Thunk<TArgs> | Thunk<Promise<TArgs>>) => Promise<{
    extensions: PluginExtensions;
    options: PluginOptions;
    restArgs: Omit<TArgs, "date" | "markdown" | "mdx" | "extensions" | "fieldOptions">;
}>;
//# sourceMappingURL=plugin.d.ts.map